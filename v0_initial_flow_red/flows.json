[
    {
        "id": "flow_materials_extraction",
        "type": "tab",
        "label": "Materials Archive Extraction",
        "disabled": false,
        "info": "Automated email-based pipeline for extracting structured metadata from architectural material PDFs using Google Gemini AI"
    },
    {
        "id": "email_trigger",
        "type": "e-mail in",
        "z": "flow_materials_extraction",
        "name": "Email Trigger",
        "protocol": "IMAP",
        "server": "${IMAP_HOST}",
        "useSSL": true,
        "port": "${IMAP_PORT}",
        "box": "INBOX",
        "disposition": "Read",
        "criteria": "UNSEEN",
        "repeat": "300",
        "fetch": "auto",
        "inputs": 0,
        "x": 110,
        "y": 200,
        "wires": [["document_validator"]]
    },
    {
        "id": "document_validator",
        "type": "function",
        "z": "flow_materials_extraction",
        "name": "Document Validator",
        "func": "const fs = require('fs');\n\n// Log input for debugging\nconst inputData = {\n    topic: msg.topic,\n    from: msg.from,\n    subject: msg.subject,\n    date: msg.date,\n    attachments: msg.attachments ? msg.attachments.length : 0\n};\nfs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    node: 'Document Validator',\n    phase: 'input',\n    data: inputData\n}) + '\\n');\n\n// Validate required email fields\nif (!msg.from) {\n    node.error('Email missing required \"from\" field. Cannot process email without sender information.');\n    return null;\n}\n\n// Store email context\nconst emailContext = {\n    subject: msg.subject,\n    from: msg.from,\n    messageId: msg.header['message-id'] || msg.messageId,\n    date: msg.date\n};\n\n// Initialize array for output messages\nconst outputMessages = [];\n\n// First message contains email context\noutputMessages.push({\n    payload: {\n        email: emailContext,\n        type: 'email_context'\n    }\n});\n\n// Process attachments\nlet pdfCount = 0;\n\nif (msg.attachments && msg.attachments.length > 0) {\n    for (let i = 0; i < msg.attachments.length; i++) {\n        const attachment = msg.attachments[i];\n        \n        if (attachment.contentType === 'application/pdf') {\n            outputMessages.push({\n                payload: {\n                    fileName: attachment.filename || `attachment_${i}.pdf`,\n                    fileSize: attachment.content.length,\n                    valid: true,\n                    type: 'pdf_document'\n                },\n                attachment: attachment\n            });\n            pdfCount++;\n        }\n    }\n}\n\n// If no PDFs found, add error message\nif (pdfCount === 0) {\n    outputMessages.push({\n        payload: {\n            fileName: 'no-pdfs-found',\n            valid: false,\n            error: 'No PDF attachments found',\n            errorType: 'validation',\n            type: 'error'\n        }\n    });\n}\n\n// Log output\nfs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    node: 'Document Validator',\n    phase: 'output',\n    messageCount: outputMessages.length,\n    pdfCount: pdfCount\n}) + '\\n');\n\n// Return array of messages\nreturn [outputMessages];",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 200,
        "wires": [["llm_extraction"]]
    },
    {
        "id": "llm_extraction",
        "type": "function",
        "z": "flow_materials_extraction",
        "name": "LLM Extraction",
        "func": "const fs = require('fs');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\n\n// Log input\nfs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    node: 'LLM Extraction',\n    phase: 'input',\n    payloadType: msg.payload.type,\n    fileName: msg.payload.fileName\n}) + '\\n');\n\n// Pass through email context messages\nif (msg.payload.type === 'email_context') {\n    return msg;\n}\n\n// Pass through invalid messages\nif (!msg.payload.valid) {\n    return msg;\n}\n\n// Check for PDF data\nif (!msg.attachment || !msg.attachment.content) {\n    msg.payload = {\n        ...msg.payload,\n        valid: false,\n        error: 'No PDF data found',\n        errorType: 'extraction'\n    };\n    return msg;\n}\n\ntry {\n    // Load prompt and schema\n    const promptPath = '/data/prompts/llm_extraction.txt';\n    const prompt = fs.readFileSync(promptPath, 'utf8');\n    const schemaPath = '/data/schema/materials_schema.json';\n    const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));\n    \n    // Get API configuration\n    const apiKey = process.env.LLM_API_KEY;\n    const modelName = process.env.LLM_MODEL;\n    \n    if (!apiKey) {\n        throw new Error('LLM_API_KEY is not defined in environment variables.');\n    }\n    if (!modelName) {\n        throw new Error('LLM_MODEL is not defined in environment variables.');\n    }\n    \n    console.log('Processing file:', msg.payload.fileName);\n    console.log('Using model:', modelName);\n    \n    // Initialize Gemini AI\n    const genAI = new GoogleGenerativeAI(apiKey);\n    const model = genAI.getGenerativeModel({\n        model: modelName,\n        generationConfig: {\n            temperature: 0.1,\n            topK: 32,\n            topP: 0.95,\n            maxOutputTokens: 8192,\n            responseMimeType: \"application/json\",\n            responseSchema: schema\n        }\n    });\n    \n    // Convert buffer to base64 for Gemini API\n    const pdfBase64 = msg.attachment.content.toString('base64');\n    \n    console.log('Making API request to Gemini for:', msg.payload.fileName);\n    \n    // Create the request\n    const apiResponse = await model.generateContent([\n        prompt + \"\\n\\nAnalyze this PDF and extract all product metadata with confidence scores. Return the result as valid JSON matching the required schema.\",\n        {\n            inlineData: {\n                mimeType: \"application/pdf\",\n                data: pdfBase64\n            }\n        }\n    ]);\n    \n    const response = await apiResponse.response;\n    const extractedContent = response.text();\n    \n    console.log('API Response received for:', msg.payload.fileName);\n    \n    if (!extractedContent) {\n        throw new Error('No content in API response');\n    }\n    \n    const extractedData = JSON.parse(extractedContent);\n    \n    // Add source file name to products if not present\n    if (extractedData.products && Array.isArray(extractedData.products)) {\n        extractedData.products.forEach(product => {\n            if (!product.source_file_name) {\n                product.source_file_name = {\n                    value: msg.payload.fileName,\n                    confidence: 1.0\n                };\n            }\n        });\n    }\n    \n    // Update message with extraction results\n    msg.payload = {\n        ...msg.payload,\n        valid: true,\n        extractedData: extractedData,\n        productCount: extractedData.products.length\n    };\n    \n    // Log success\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n        timestamp: new Date().toISOString(),\n        node: 'LLM Extraction',\n        phase: 'output',\n        fileName: msg.payload.fileName,\n        productCount: extractedData.products.length,\n        status: 'success'\n    }) + '\\n');\n    \n    return msg;\n    \n} catch (error) {\n    console.error('Extraction failed for:', msg.payload.fileName, error.message);\n    \n    // Update message with error\n    msg.payload = {\n        ...msg.payload,\n        valid: false,\n        error: error.message,\n        errorType: 'extraction'\n    };\n    \n    // Log error\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n        timestamp: new Date().toISOString(),\n        node: 'LLM Extraction',\n        phase: 'output',\n        fileName: msg.payload.fileName,\n        status: 'error',\n        error: error.message\n    }) + '\\n');\n    \n    return msg;\n}",
        "outputs": 1,
        "timeout": "60",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "GoogleGenerativeAI",
                "module": "@google/generative-ai"
            }
        ],
        "x": 540,
        "y": 200,
        "wires": [["result_aggregator"]]
    },
    {
        "id": "result_aggregator",
        "type": "join",
        "z": "flow_materials_extraction",
        "name": "Result Aggregator",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "5",
        "count": "",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 750,
        "y": 200,
        "wires": [["result_processor"]]
    },
    {
        "id": "result_processor",
        "type": "function",
        "z": "flow_materials_extraction",
        "name": "Result Processor",
        "func": "const fs = require('fs');\n\n// Helper functions\nfunction escapeHtml(text) {\n    if (!text) return '';\n    return String(text)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\nfunction formatValue(field) {\n    if (Array.isArray(field.value)) {\n        return field.value.join(', ');\n    }\n    return String(field.value);\n}\n\nfunction createProductTable(product, fileName) {\n    const supplier = formatValue(product.supplier);\n    const productName = formatValue(product.product_name);\n    const sku = formatValue(product.sku_number);\n    \n    let html = `\n        <table class=\"header-table\">\n            <tr>\n                <th>Supplier</th>\n                <th>Product Name</th>\n                <th>SKU</th>\n                <th>Source File</th>\n            </tr>\n            <tr>\n                <td>${escapeHtml(supplier)}</td>\n                <td>${escapeHtml(productName)}</td>\n                <td>${escapeHtml(sku)}</td>\n                <td>${escapeHtml(fileName)}</td>\n            </tr>\n        </table>\n    `;\n    \n    html += `\n        <table class=\"data-table\">\n            <tr>\n                <th>Field</th>\n                <th>Value</th>\n            </tr>\n    `;\n    \n    for (const [fieldKey, fieldData] of Object.entries(product)) {\n        if (['supplier', 'product_name', 'sku_number', 'source_file_name'].includes(fieldKey)) continue;\n        \n        if (fieldData && typeof fieldData === 'object' && fieldData.value !== null && fieldData.value !== undefined && fieldData.value !== '') {\n            const value = formatValue(fieldData);\n            if (value && value.trim && value.trim() !== '') {\n                const fieldLabel = fieldKey.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                html += `\n            <tr>\n                <td>${fieldLabel}</td>\n                <td>${escapeHtml(value)}</td>\n            </tr>`;\n            }\n        }\n    }\n    \n    html += `\n        </table>\n    `;\n    \n    return html;\n}\n\nfunction createRequestDetailsTable(emailContext) {\n    return `\n        <table>\n            <tr>\n                <th>From</th>\n                <td>${escapeHtml(emailContext.from)}</td>\n            </tr>\n            <tr>\n                <th>Subject</th>\n                <td>${escapeHtml(emailContext.subject)}</td>\n            </tr>\n            <tr>\n                <th>Date</th>\n                <td>${escapeHtml(emailContext.date)}</td>\n            </tr>\n            <tr>\n                <th>Message ID</th>\n                <td>${escapeHtml(emailContext.messageId)}</td>\n            </tr>\n        </table>\n    `;\n}\n\nfunction createFailedFilesSection(errors) {\n    if (errors.length === 0) {\n        return '';\n    }\n    \n    let html = `\n        <div class=\"failed-files\">\n            <h3>Processing Issues</h3>\n            <p>The following files could not be processed:</p>\n            <ul>`;\n    \n    errors.forEach(error => {\n        html += `<li><strong>${escapeHtml(error.fileName)}:</strong> ${escapeHtml(error.error)}</li>`;\n    });\n    \n    html += `\n            </ul>\n        </div>`;\n    \n    return html;\n}\n\n// Log input\nfs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    node: 'Result Processor',\n    phase: 'input',\n    itemCount: msg.payload.length\n}) + '\\n');\n\n// Process all items\nconst allItems = msg.payload;\nconst emailContextItem = allItems.find(item => item.type === 'email_context');\n\nif (!emailContextItem) {\n    node.error('Email context not found in input');\n    return null;\n}\n\nconst emailContext = emailContextItem.email;\nconst pdfItems = allItems.filter(item => item.type === 'pdf_document' || item.type === 'error');\nconst validPdfs = pdfItems.filter(item => item.fileName !== 'no-pdfs-found');\nconst totalAttachments = validPdfs.length;\n\n// Collect results\nconst allProducts = [];\nconst errors = [];\nconst summaries = [];\nconst exceptions = [];\n\nfor (const item of pdfItems) {\n    if (!item.valid) {\n        errors.push({\n            fileName: item.fileName,\n            error: item.error,\n            errorType: item.errorType\n        });\n        continue;\n    }\n    \n    const products = item.extractedData.products;\n    const summary = item.extractedData.processing_summary;\n    const processingExceptions = item.extractedData.processing_exceptions;\n    \n    if (summary) {\n        summaries.push(`${item.fileName}: ${summary}`);\n    }\n    \n    if (processingExceptions) {\n        if (Array.isArray(processingExceptions)) {\n            exceptions.push(...processingExceptions.map(ex => `${item.fileName}: ${ex}`));\n        } else if (typeof processingExceptions === 'string') {\n            exceptions.push(`${item.fileName}: ${processingExceptions}`);\n        }\n    }\n    \n    for (const product of products) {\n        allProducts.push({\n            product: product,\n            fileName: item.fileName\n        });\n    }\n}\n\n// Determine status and create email body\nconst status = allProducts.length > 0 ? 'success' : 'failure';\nconst requestDetails = createRequestDetailsTable(emailContext);\nlet emailBody = '';\n\nif (status === 'success') {\n    const templatePath = '/data/email_templates/success.html';\n    let template = fs.readFileSync(templatePath, 'utf8');\n    \n    let productTables = '';\n    allProducts.forEach((productInfo, idx) => {\n        if (idx > 0) productTables += '<br>';\n        productTables += createProductTable(productInfo.product, productInfo.fileName);\n    });\n    \n    let extractionSummary = '';\n    if (summaries.length > 0) {\n        extractionSummary = '<ul>' + summaries.map(summary => `<li>${escapeHtml(summary)}</li>`).join('') + '</ul>';\n    } else {\n        extractionSummary = `<ul><li>Processed ${allProducts.length} product(s) from ${totalAttachments} attachment(s).</li></ul>`;\n    }\n    \n    const modelInfo = process.env.LLM_MODEL ? ` using model <strong>${escapeHtml(process.env.LLM_MODEL)}</strong>` : '';\n    extractionSummary += `<div>${modelInfo}</div>`;\n    \n    let exceptionsSection = '';\n    if (exceptions.length > 0) {\n        exceptionsSection = `\n        <div class=\"exceptions\">\n            <h3>Processing Exceptions</h3>\n            <ul>`;\n        exceptions.forEach(exception => {\n            exceptionsSection += `<li>${escapeHtml(exception)}</li>`;\n        });\n        exceptionsSection += `\n            </ul>\n        </div>`;\n    }\n    \n    const failedFilesSection = createFailedFilesSection(errors);\n    \n    emailBody = template\n        .replace('{{productTables}}', productTables)\n        .replace('{{extractionSummary}}', extractionSummary)\n        .replace('{{exceptionsSection}}', exceptionsSection)\n        .replace('{{failedFilesSection}}', failedFilesSection)\n        .replace('{{requestDetails}}', requestDetails)\n        .replace('{{totalProducts}}', allProducts.length)\n        .replace('{{totalAttachments}}', totalAttachments);\n        \n} else {\n    const templatePath = '/data/email_templates/failure.html';\n    let template = fs.readFileSync(templatePath, 'utf8');\n    \n    let errorDetails = '';\n    if (errors.length > 0) {\n        errorDetails = errors.map(e => `<strong>${e.fileName}:</strong> ${e.error}`).join('<br>');\n    } else {\n        errorDetails = 'No specific error details available.';\n    }\n    \n    emailBody = template\n        .replace('{{errorDetails}}', errorDetails)\n        .replace('{{requestDetails}}', requestDetails)\n        .replace('{{totalAttachments}}', totalAttachments);\n}\n\n// Prepare output message\nmsg.to = emailContext.from;\nmsg.subject = `Re: ${emailContext.subject} - Materials Extraction ${status === 'success' ? 'Complete' : 'Failed'}`;\nmsg.html = emailBody;\nmsg.payload = {\n    to: emailContext.from,\n    subject: msg.subject,\n    status: status,\n    processingTimestamp: new Date().toISOString(),\n    productCount: allProducts.length,\n    errorCount: errors.length\n};\n\n// Log output\nfs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    node: 'Result Processor',\n    phase: 'output',\n    status: status,\n    productCount: allProducts.length,\n    errorCount: errors.length,\n    to: emailContext.from\n}) + '\\n');\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 200,
        "wires": [["send_notification"]]
    },
    {
        "id": "send_notification",
        "type": "e-mail",
        "z": "flow_materials_extraction",
        "name": "Send Notification",
        "server": "${SMTP_HOST}",
        "port": "${SMTP_PORT}",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": true,
        "tls": true,
        "x": 1170,
        "y": 200,
        "wires": []
    }
]