[{"createdAt":"2025-05-26T14:05:22.415Z","updatedAt":"2025-05-29T21:50:38.000Z","id":"SjsG0ctMg0DMZCMn","name":"materials-archive-extraction","active":false,"isArchived":false,"nodes":[{"parameters":{"downloadAttachments":true,"options":{}},"id":"369bb9d9-bca1-4d5b-9b31-42d590a83833","name":"Email Trigger","type":"n8n-nodes-base.emailReadImap","typeVersion":2,"position":[440,-160],"credentials":{"imap":{"id":"C0hVlGBFoXXFM3Mg","name":"IMAP account"}}},{"parameters":{"jsCode":"const fs = require('fs');\n\nconst inputData = $input.all().map(item => ({\n  json: item.json, \n  binaryMeta: Object.keys(item.binary || {}).map(key => ({\n    key: key,\n    fileName: item.binary[key].fileName,\n    mimeType: item.binary[key].mimeType,\n    dataLength: item.binary[key].data ? item.binary[key].data.length : 0\n  }))\n}));\nfs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"Document Validator\",\"phase\":\"input\",\"data\":inputData}) + '\\n');\n\nconst items = [];\n\nfor (const item of $input.all()) {\n  const email = item.json;\n  const attachments = Object.keys(item.binary);\n  \n  const emailContext = {\n    subject: email.subject,\n    from: email.from,\n    messageId: email.metadata && email.metadata[\"message-id\"] ? email.metadata[\"message-id\"] : email.messageId,\n    date: email.date\n  };\n  \n  items.push({\n    json: {\n      email: emailContext\n    }\n  });\n  \n  let pdfCount = 0;\n  \n  for (let i = 0; i < attachments.length; i++) {\n    const attachmentKey = attachments[i];\n    const attachment = item.binary[attachmentKey];\n    \n    if (attachment.mimeType === 'application/pdf') {\n      const processItem = {\n        json: {\n          fileName: attachment.fileName || attachmentKey,\n          fileSize: attachment.data.length,\n          valid: true\n        },\n        binary: {\n          pdf: attachment\n        }\n      };\n      \n      items.push(processItem);\n      pdfCount++;\n    }\n  }\n  \n  if (pdfCount === 0) {\n    items.push({\n      json: {\n        fileName: 'no-pdfs-found',\n        valid: false,\n        error: 'No PDF attachments found',\n        errorType: 'validation'\n      }\n    });\n  }\n}\n\nconst outputData = items.map(item => ({\n  json: item.json, \n  binaryMeta: Object.keys(item.binary || {}).map(key => ({\n    key: key,\n    fileName: item.binary[key].fileName,\n    mimeType: item.binary[key].mimeType,\n    dataLength: item.binary[key].data ? item.binary[key].data.length : 0\n  }))\n}));\nfs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"Document Validator\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n\nreturn items;"},"id":"1e758620-62bb-46f1-be80-30bdb649d55f","name":"Document Validator","type":"n8n-nodes-base.code","typeVersion":2,"position":[640,-160]},{"parameters":{"mode":"runOnceForEachItem","jsCode":"const fs = require('fs');\nconst https = require('https');\n\nconst inputData = {\n  json: $input.item.json, \n  binaryMeta: Object.keys($input.item.binary || {}).map(key => ({\n    key: key,\n    fileName: $input.item.binary[key].fileName,\n    mimeType: $input.item.binary[key].mimeType,\n    dataLength: $input.item.binary[key].data ? $input.item.binary[key].data.length : 0\n  }))\n};\nfs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"input\",\"data\":inputData}) + '\\n');\n\nif ($input.item.json.email && !$input.item.json.fileName) {\n  const outputData = {\n    json: $input.item.json, \n    binaryMeta: []\n  };\n  fs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n  return $input.item;\n}\n\nif (!$input.item.json.valid) {\n  const outputData = {\n    json: $input.item.json, \n    binaryMeta: Object.keys($input.item.binary || {}).map(key => ({\n      key: key,\n      fileName: $input.item.binary[key].fileName,\n      mimeType: $input.item.binary[key].mimeType,\n      dataLength: $input.item.binary[key].data ? $input.item.binary[key].data.length : 0\n    }))\n  };\n  fs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n  return $input.item;\n}\n\nconst item = $input.item;\nconst pdfData = item.binary.pdf.data;\n\nif (!pdfData) {\n  const result = {\n    json: {\n      ...item.json,\n      valid: false,\n      error: 'No PDF data found',\n      errorType: 'extraction'\n    }\n  };\n  const outputData = {\n    json: result.json, \n    binaryMeta: Object.keys(result.binary || {}).map(key => ({\n      key: key,\n      fileName: result.binary[key].fileName,\n      mimeType: result.binary[key].mimeType,\n      dataLength: result.binary[key].data ? result.binary[key].data.length : 0\n    }))\n  };\n  fs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n  return result;\n}\n\ntry {\n  const promptPath = '/home/node/prompts/llm_extraction.txt';\n  const prompt = fs.readFileSync(promptPath, 'utf8');\n  const schemaPath = '/home/node/schema/materials_schema.json';\n  const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));\n  \n  const apiKey = $env.LLM_API_KEY;\n  console.log('Using API Key:', apiKey ? `${apiKey.substring(0, 10)}...` : 'NOT SET');\n  console.log('Processing file:', item.json.fileName);\n  console.log('PDF data length:', pdfData.length);\n  \n  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;\n  \n  const requestBody = {\n    contents: [{\n      parts: [\n        {\n          text: prompt + \"\\n\\nAnalyze this PDF and extract all product metadata with confidence scores. Return the result as valid JSON matching the required schema.\"\n        },\n        {\n          inline_data: {\n            mime_type: \"application/pdf\",\n            data: pdfData\n          }\n        }\n      ]\n    }],\n    generationConfig: {\n      temperature: 0.1,\n      topK: 32,\n      topP: 0.95,\n      maxOutputTokens: 8192,\n      responseMimeType: \"application/json\",\n      responseSchema: schema\n    }\n  };\n  \n  console.log('Making API request to Gemini for:', item.json.fileName);\n  const response = await new Promise((resolve, reject) => {\n    const req = https.request(apiUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          const parsed = JSON.parse(data);\n          console.log('API Response Status:', res.statusCode, 'for:', item.json.fileName);\n          resolve(parsed);\n        } catch (e) {\n          console.error('Failed to parse API response for:', item.json.fileName, data);\n          reject(new Error(`Failed to parse API response: ${data}`));\n        }\n      });\n    });\n    \n    req.on('error', reject);\n    req.write(JSON.stringify(requestBody));\n    req.end();\n  });\n  \n  if (response.error) {\n    throw new Error(`API Error: ${response.error.message}`);\n  }\n  \n  const extractedContent = response.candidates[0].content.parts[0].text;\n  \n  if (!extractedContent) {\n    throw new Error('No content in API response');\n  }\n  \n  const extractedData = JSON.parse(extractedContent);\n  \n  if (extractedData.products && Array.isArray(extractedData.products)) {\n    extractedData.products.forEach(product => {\n      if (!product.source_file_name) {\n        product.source_file_name = {\n          value: item.json.fileName,\n          confidence: 1.0\n        };\n      }\n    });\n  }\n  \n  const result = {\n    json: {\n      ...item.json,\n      valid: true,\n      extractedData: extractedData,\n      productCount: extractedData.products.length\n    },\n    binary: item.binary\n  };\n  \n  const outputData = {\n    json: result.json, \n    binaryMeta: Object.keys(result.binary || {}).map(key => ({\n      key: key,\n      fileName: result.binary[key].fileName,\n      mimeType: result.binary[key].mimeType,\n      dataLength: result.binary[key].data ? result.binary[key].data.length : 0\n    }))\n  };\n  fs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n  \n  return result;\n  \n} catch (error) {\n  console.error('Extraction failed for:', item.json.fileName, error.message);\n  const result = {\n    json: {\n      ...item.json,\n      valid: false,\n      error: error.message,\n      errorType: 'extraction'\n    }\n  };\n  \n  const outputData = {\n    json: result.json, \n    binaryMeta: Object.keys(result.binary || {}).map(key => ({\n      key: key,\n      fileName: result.binary[key].fileName,\n      mimeType: result.binary[key].mimeType,\n      dataLength: result.binary[key].data ? result.binary[key].data.length : 0\n    }))\n  };\n  fs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"LLM Extraction\",\"phase\":\"output\",\"data\":outputData}) + '\\n');\n  \n  return result;\n}"},"id":"e974399d-51db-431b-8fee-106758648896","name":"LLM Extraction","type":"n8n-nodes-base.code","typeVersion":2,"position":[840,-160]},{"parameters":{"jsCode":"const fs = require('fs');\n\nconst inputData = $input.all().map(item => ({\n  json: item.json, \n  binaryMeta: Object.keys(item.binary || {}).map(key => ({\n    key: key,\n    fileName: item.binary[key].fileName,\n    mimeType: item.binary[key].mimeType,\n    dataLength: item.binary[key].data ? item.binary[key].data.length : 0\n  }))\n}));\nfs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"Result Processor\",\"phase\":\"input\",\"data\":inputData}) + '\\n');\n\nconst allItems = $input.all();\nconst emailContextItem = allItems.find(item => item.json.email && !item.json.fileName);\nif (!emailContextItem) {\n  throw new Error('Email context item not found in input');\n}\nconst emailContext = emailContextItem.json.email;\n\nconst pdfItems = allItems.filter(item => item.json.fileName || item.json.error);\nconst validPdfs = pdfItems.filter(i => i.json.fileName !== 'no-pdfs-found');\nconst totalAttachments = validPdfs.length;\n\nfunction escapeHtml(text) {\n  if (!text) return '';\n  return String(text)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction formatValue(field) {\n  if (Array.isArray(field.value)) {\n    return field.value.join(', ');\n  }\n  return String(field.value);\n}\n\nfunction createProductTable(product, fileName) {\n  const supplier = formatValue(product.supplier);\n  const productName = formatValue(product.product_name);\n  const sku = formatValue(product.sku_number);\n  \n  let html = `\n    <table class=\"header-table\">\n      <tr>\n        <th>Supplier</th>\n        <th>Product Name</th>\n        <th>SKU</th>\n        <th>Source File</th>\n      </tr>\n      <tr>\n        <td>${escapeHtml(supplier)}</td>\n        <td>${escapeHtml(productName)}</td>\n        <td>${escapeHtml(sku)}</td>\n        <td>${escapeHtml(fileName)}</td>\n      </tr>\n    </table>\n  `;\n  \n  html += `\n    <table class=\"data-table\">\n      <tr>\n        <th>Field</th>\n        <th>Value</th>\n      </tr>\n  `;\n  \n  for (const [fieldKey, fieldData] of Object.entries(product)) {\n    if (['supplier', 'product_name', 'sku_number', 'source_file_name'].includes(fieldKey)) continue;\n    \n    if (fieldData && typeof fieldData === 'object' && fieldData.value !== null && fieldData.value !== undefined && fieldData.value !== '') {\n      const value = formatValue(fieldData);\n      if (value && value.trim && value.trim() !== '') {\n        const fieldLabel = fieldKey.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        html += `\n      <tr>\n        <td>${fieldLabel}</td>\n        <td>${escapeHtml(value)}</td>\n      </tr>`;\n      }\n    }\n  }\n  \n  html += `\n    </table>\n  `;\n  \n  return html;\n}\n\nfunction createRequestDetailsTable(emailContext) {\n  return `\n    <table>\n      <tr>\n        <th>From</th>\n        <td>${escapeHtml(emailContext.from)}</td>\n      </tr>\n      <tr>\n        <th>Subject</th>\n        <td>${escapeHtml(emailContext.subject)}</td>\n      </tr>\n      <tr>\n        <th>Date</th>\n        <td>${escapeHtml(emailContext.date)}</td>\n      </tr>\n      <tr>\n        <th>Message ID</th>\n        <td>${escapeHtml(emailContext.messageId)}</td>\n      </tr>\n    </table>\n  `;\n}\n\nfunction createFailedFilesSection(errors) {\n  if (errors.length === 0) {\n    return '';\n  }\n  \n  let html = `\n    <div class=\"failed-files\">\n        <h3>Processing Issues</h3>\n        <p>The following files could not be processed:</p>\n        <ul>`;\n  \n  errors.forEach(error => {\n    html += `<li><strong>${escapeHtml(error.fileName)}:</strong> ${escapeHtml(error.error)}</li>`;\n  });\n  \n  html += `\n        </ul>\n    </div>`;\n  \n  return html;\n}\n\nconst allProducts = [];\nconst errors = [];\nconst summaries = [];\nconst exceptions = [];\n\nfor (const item of pdfItems) {\n  if (!item.json.valid) {\n    errors.push({\n      fileName: item.json.fileName,\n      error: item.json.error,\n      errorType: item.json.errorType\n    });\n    continue;\n  }\n  \n  const products = item.json.extractedData.products;\n  const summary = item.json.extractedData.processing_summary;\n  const processingExceptions = item.json.extractedData.processing_exceptions;\n  \n  if (summary) {\n    summaries.push(`${item.json.fileName}: ${summary}`);\n  }\n  \n  if (processingExceptions) {\n    if (Array.isArray(processingExceptions)) {\n      exceptions.push(...processingExceptions.map(ex => `${item.json.fileName}: ${ex}`));\n    } else if (typeof processingExceptions === 'string') {\n      exceptions.push(`${item.json.fileName}: ${processingExceptions}`);\n    }\n  }\n  \n  for (const product of products) {\n    allProducts.push({\n      product: product,\n      fileName: item.json.fileName\n    });\n  }\n}\n\nconst status = allProducts.length > 0 ? 'success' : 'failure';\nconst requestDetails = createRequestDetailsTable(emailContext);\nlet emailBody = '';\n\nif (status === 'success') {\n  const templatePath = '/home/node/email_templates/success.html';\n  let template = fs.readFileSync(templatePath, 'utf8');\n  \n  let productTables = '';\n  allProducts.forEach((productInfo, idx) => {\n    if (idx > 0) productTables += '<br>';\n    productTables += createProductTable(productInfo.product, productInfo.fileName);\n  });\n  \n  let extractionSummary = '';\n  if (summaries.length > 0) {\n    extractionSummary = '<ul>' + summaries.map(summary => `<li>${escapeHtml(summary)}</li>`).join('') + '</ul>';\n  } else {\n    extractionSummary = `<ul><li>Successfully extracted ${allProducts.length} product(s) from ${totalAttachments} file(s).</li></ul>`;\n  }\n  \n  let exceptionsSection = '';\n  if (exceptions.length > 0) {\n    exceptionsSection = `\n    <div class=\"exceptions\">\n        <h3>Processing Exceptions</h3>\n        <ul>`;\n    exceptions.forEach(exception => {\n      exceptionsSection += `<li>${escapeHtml(exception)}</li>`;\n    });\n    exceptionsSection += `\n        </ul>\n    </div>`;\n  }\n  \n  const failedFilesSection = createFailedFilesSection(errors);\n  \n  emailBody = template\n    .replace('{{productTables}}', productTables)\n    .replace('{{extractionSummary}}', extractionSummary)\n    .replace('{{exceptionsSection}}', exceptionsSection)\n    .replace('{{failedFilesSection}}', failedFilesSection)\n    .replace('{{requestDetails}}', requestDetails)\n    .replace('{{totalProducts}}', allProducts.length)\n    .replace('{{totalAttachments}}', totalAttachments);\n    \n} else {\n  const templatePath = '/home/node/email_templates/failure.html';\n  let template = fs.readFileSync(templatePath, 'utf8');\n  \n  let errorDetails = '';\n  if (errors.length > 0) {\n    errorDetails = errors.map(e => `<strong>${e.fileName}:</strong> ${e.error}`).join('<br>');\n  } else {\n    errorDetails = 'No specific error details available.';\n  }\n  \n  emailBody = template\n    .replace('{{errorDetails}}', errorDetails)\n    .replace('{{requestDetails}}', requestDetails)\n    .replace('{{totalAttachments}}', totalAttachments);\n}\n\nconst result = {\n  json: {\n    to: emailContext.from,\n    subject: `Re: ${emailContext.subject} - Materials Extraction ${status === 'success' ? 'Complete' : 'Failed'}`,\n    body: emailBody,\n    messageId: emailContext.messageId,\n    status: status,\n    processingTimestamp: new Date().toISOString()\n  }\n};\n\nfs.appendFileSync('/home/node/data/debug.log', JSON.stringify({\"timestamp\":new Date().toISOString(),\"executionId\":$execution.id,\"node\":\"Result Processor\",\"phase\":\"output\",\"data\":[result]}) + '\\n');\n\nreturn [result];"},"id":"2bdfedf6-1750-4a43-8db1-6bafb23c26ac","name":"Result Processor","type":"n8n-nodes-base.code","typeVersion":2,"position":[1040,-160]},{"parameters":{"fromEmail":"={{ $env.EMAIL_USER }}","toEmail":"={{ $json.to }}","subject":"={{ $json.subject }}","emailFormat":"html","html":"={{ $json.body }}","options":{}},"id":"1ac4f80d-8214-4eb9-986e-394428c2cc44","name":"Send Notification","type":"n8n-nodes-base.emailSend","typeVersion":2,"position":[1240,-160],"webhookId":"1ae1ebae-1ce9-46b6-a2b7-660a90b76597","credentials":{"smtp":{"id":"BMsHcigGcD5bNsbG","name":"SMTP account"}}}],"connections":{"Email Trigger":{"main":[[{"node":"Document Validator","type":"main","index":0}]]},"Document Validator":{"main":[[{"node":"LLM Extraction","type":"main","index":0}]]},"LLM Extraction":{"main":[[{"node":"Result Processor","type":"main","index":0}]]},"Result Processor":{"main":[[{"node":"Send Notification","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":null,"pinData":{},"versionId":"436297a4-4d24-4c2c-b6d3-763ea9a160f0","triggerCount":0,"tags":[]}]