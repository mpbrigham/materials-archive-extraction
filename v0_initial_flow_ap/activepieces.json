{
  "name": "Material Extraction from Email",
  "trigger": {
    "name": "imap",
    "type": "IMAP",
    "settings": {
      "host": "{{IMAP_HOST}}",
      "port": "{{IMAP_PORT}}",
      "username": "{{EMAIL_USER}}",
      "password": "{{EMAIL_PASS}}",
      "tls": true,
      "mailbox": "INBOX",
      "criteria": ["UNSEEN"]
    },
    "nextAction": {
      "name": "read_config",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs').promises;\n\nmodule.exports = async (data) => {\n  const prompt = await fs.readFile('/data/prompts/llm_extraction.txt', 'utf8');\n  const schema = JSON.parse(await fs.readFile('/data/schema/materials_schema.json', 'utf8'));\n  const successTemplate = await fs.readFile('/data/email_templates/success.html', 'utf8');\n  const failureTemplate = await fs.readFile('/data/email_templates/failure.html', 'utf8');\n\n  return {\n    prompt,\n    schema,\n    successTemplate,\n    failureTemplate\n  };\n};"
      }
    }
  },
  "actions": [
    {
      "name": "document_validator",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs');\n\nmodule.exports = (data) => {\n  const items = [];\n  const email = data.imap;\n  \n  // Debug logging - input\n  const inputData = { email };\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Document Validator',\n    phase: 'input',\n    data: inputData\n  }) + '\\n');\n  \n  // First item: Email context (MUST be first for result processor)\n  items.push({\n    email: {\n      subject: email.subject,\n      from: email.from,\n      messageId: email.messageId || (email.metadata && email.metadata['message-id']),\n      date: email.date\n    }\n  });\n  \n  // Process attachments - only PDFs\n  let pdfCount = 0;\n  \n  if (email.attachments && email.attachments.length > 0) {\n    for (const attachment of email.attachments) {\n      if (attachment.mimeType === 'application/pdf') {\n        if (!attachment.fileName) {\n          throw new Error('PDF attachment missing fileName');\n        }\n        if (attachment.size === undefined || attachment.size === null) {\n          throw new Error(`PDF attachment ${attachment.fileName} missing size`);\n        }\n        \n        items.push({\n          fileName: attachment.fileName,\n          fileSize: attachment.size,\n          valid: true,\n          attachmentRef: attachment  // ActivePieces file reference\n        });\n        pdfCount++;\n      }\n    }\n  }\n  \n  // Add error item if no PDFs found\n  if (pdfCount === 0) {\n    items.push({\n      fileName: 'no-pdfs-found',\n      valid: false,\n      error: 'No PDF attachments found in email',\n      errorType: 'validation'\n    });\n  }\n  \n  // Debug logging - output\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Document Validator',\n    phase: 'output',\n    data: { items }\n  }) + '\\n');\n  \n  return { items };\n};"
      },
      "nextAction": {
        "name": "loop",
        "type": "LOOP_ON_ITEMS",
        "settings": {
          "items": "{{document_validator.items}}"
        }
      }
    },
    {
      "name": "extract_metadata",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\n\nmodule.exports = async (data) => {\n  const item = data.loop.item;\n  \n  // Debug logging - input\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'LLM Extraction',\n    phase: 'input',\n    data: { item }\n  }) + '\\n');\n  \n  // Skip email context item\n  if (item.email) {\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item }\n    }) + '\\n');\n    return item;\n  }\n  \n  // Pass through invalid items\n  if (!item.valid) {\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item }\n    }) + '\\n');\n    return item;\n  }\n  \n  try {\n    // Get model name - no fallback\n    const modelName = process.env.LLM_MODEL;\n    if (!modelName) {\n      throw new Error('LLM_MODEL environment variable is required');\n    }\n    \n    console.log('Processing file:', item.fileName);\n    console.log('Using model:', modelName);\n    \n    // Initialize Gemini\n    const apiKey = process.env.LLM_API_KEY;\n    if (!apiKey) {\n      throw new Error('LLM_API_KEY is not defined in environment variables');\n    }\n    \n    const genAI = new GoogleGenerativeAI(apiKey);\n    const model = genAI.getGenerativeModel({ \n      model: modelName,\n      generationConfig: {\n        temperature: 0.1,\n        topK: 32,\n        topP: 0.95,\n        maxOutputTokens: 8192,\n        responseMimeType: \"application/json\",\n        responseSchema: data.read_config.schema\n      }\n    });\n    \n    // Debug log attachment structure\n    const attachmentRef = item.attachmentRef;\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'attachment-debug',\n      data: {\n        fileName: item.fileName,\n        attachmentRefKeys: Object.keys(attachmentRef),\n        attachmentRef: attachmentRef\n      }\n    }) + '\\n');\n    \n    // For now, we assume ActivePieces provides db:// references that can be used directly\n    // This needs verification based on the debug log\n    let pdfBase64;\n    \n    // Check if attachment has data property (direct content)\n    if (attachmentRef.data) {\n      pdfBase64 = Buffer.from(attachmentRef.data).toString('base64');\n    } else if (attachmentRef.base64) {\n      // Already base64 encoded\n      pdfBase64 = attachmentRef.base64;\n    } else {\n      // This is likely a db:// reference\n      throw new Error(`Unable to process attachment reference. Debug log contains attachment structure for: ${item.fileName}`);\n    }\n    \n    console.log('PDF data length:', pdfBase64.length);\n    \n    // Make API call\n    const result = await model.generateContent([\n      data.read_config.prompt + \"\\n\\nAnalyze this PDF and extract all product metadata with confidence scores. Return the result as valid JSON matching the required schema.\",\n      {\n        inlineData: {\n          mimeType: \"application/pdf\",\n          data: pdfBase64\n        }\n      }\n    ]);\n    \n    const response = await result.response;\n    const extractedContent = response.text();\n    \n    if (!extractedContent) {\n      throw new Error('No content in API response');\n    }\n    \n    const extractedData = JSON.parse(extractedContent);\n    \n    // Add source_file_name to each product\n    if (extractedData.products && Array.isArray(extractedData.products)) {\n      extractedData.products.forEach(product => {\n        if (!product.source_file_name) {\n          product.source_file_name = {\n            value: item.fileName,\n            confidence: 1.0\n          };\n        }\n      });\n    }\n    \n    const resultItem = {\n      ...item,\n      valid: true,\n      extractedData: extractedData,\n      productCount: extractedData.products ? extractedData.products.length : 0,\n      usedModel: modelName\n    };\n    \n    // Debug logging - output\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item: resultItem }\n    }) + '\\n');\n    \n    return resultItem;\n    \n  } catch (error) {\n    console.error('Extraction failed for:', item.fileName, error.message);\n    \n    // Return item with error - no fallbacks\n    const errorItem = {\n      ...item,\n      valid: false,\n      error: error.message,\n      errorType: 'extraction'\n    };\n    \n    // Debug logging - error output\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output-error',\n      data: { item: errorItem, error: error.message }\n    }) + '\\n');\n    \n    return errorItem;\n  }\n};"
      },
      "nextAction": {
        "name": "format_results",
        "type": "CODE",
        "settings": {
          "code": "const fs = require('fs');\n\nmodule.exports = (data) => {\n  // Debug logging - input\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Result Processor',\n    phase: 'input',\n    data: { itemCount: data.loop.length }\n  }) + '\\n');\n  \n  // HTML escape function for security\n  function escapeHtml(text) {\n    if (!text) return '';\n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n  \n  // Format value helper\n  function formatValue(field) {\n    if (Array.isArray(field.value)) {\n      return field.value.join(', ');\n    }\n    return String(field.value);\n  }\n  \n  // Get all processed items\n  const allItems = data.loop;\n  \n  // Find email context (first item)\n  const emailContextItem = allItems.find(item => item.email && !item.fileName);\n  if (!emailContextItem) {\n    throw new Error('Email context item not found');\n  }\n  const emailContext = emailContextItem.email;\n  \n  // Separate PDF items\n  const pdfItems = allItems.filter(item => item.fileName);\n  const validPdfs = pdfItems.filter(item => item.fileName !== 'no-pdfs-found');\n  \n  // Collect model info (get from first successful extraction)\n  const firstSuccess = pdfItems.find(item => item.usedModel);\n  const modelInfo = firstSuccess ? ` using model <strong>${escapeHtml(firstSuccess.usedModel)}</strong>` : '';\n  \n  // Process results\n  const errors = [];\n  const allProducts = [];\n  const summaries = [];\n  const exceptions = [];\n  let totalProducts = 0;\n  \n  for (const item of pdfItems) {\n    if (!item.valid || !item.extractedData) {\n      if (!item.error) {\n        throw new Error(`Invalid item missing error message: ${JSON.stringify(item)}`);\n      }\n      if (!item.errorType) {\n        throw new Error(`Invalid item missing errorType: ${JSON.stringify(item)}`);\n      }\n      \n      errors.push({\n        fileName: item.fileName,\n        error: item.error,\n        errorType: item.errorType\n      });\n    } else {\n      // Collect products\n      if (item.extractedData.products) {\n        for (const product of item.extractedData.products) {\n          allProducts.push({\n            product: product,\n            fileName: item.fileName\n          });\n          totalProducts++;\n        }\n      }\n      \n      // Collect processing summary\n      if (item.extractedData.processing_summary) {\n        summaries.push(`${item.fileName}: ${item.extractedData.processing_summary}`);\n      }\n      \n      // Collect processing exceptions\n      if (item.extractedData.processing_exceptions) {\n        if (Array.isArray(item.extractedData.processing_exceptions)) {\n          exceptions.push(...item.extractedData.processing_exceptions.map(\n            ex => `${item.fileName}: ${ex}`\n          ));\n        } else {\n          exceptions.push(`${item.fileName}: ${item.extractedData.processing_exceptions}`);\n        }\n      }\n    }\n  }\n  \n  // Determine which template to use\n  const hasProducts = totalProducts > 0;\n  const template = hasProducts ? data.read_config.successTemplate : data.read_config.failureTemplate;\n  \n  // Build HTML\n  let html = template;\n  \n  if (hasProducts) {\n    // Build product tables\n    let productTables = '';\n    for (const {product, fileName} of allProducts) {\n      // Header table\n      productTables += `\n      <table class=\"header-table\">\n        <tr>\n          <th>Supplier</th>\n          <th>Product Name</th>\n          <th>SKU</th>\n          <th>Source File</th>\n        </tr>\n        <tr>\n          <td>${escapeHtml(formatValue(product.supplier))}</td>\n          <td>${escapeHtml(formatValue(product.product_name))}</td>\n          <td>${escapeHtml(formatValue(product.sku_number))}</td>\n          <td>${escapeHtml(fileName)}</td>\n        </tr>\n      </table>`;\n      \n      // Data table\n      productTables += `\n      <table class=\"data-table\">\n        <tr>\n          <th>Field</th>\n          <th>Value</th>\n        </tr>`;\n      \n      for (const [key, field] of Object.entries(product)) {\n        if (!['supplier', 'product_name', 'sku_number', 'source_file_name'].includes(key)) {\n          if (field && field.value !== null && field.value !== undefined && field.value !== '') {\n            const value = Array.isArray(field.value) ? field.value.join(', ') : field.value;\n            const fieldLabel = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            productTables += `\n        <tr>\n          <td>${escapeHtml(fieldLabel)}</td>\n          <td>${escapeHtml(value)}</td>\n        </tr>`;\n          }\n        }\n      }\n      productTables += '\n      </table><br>';\n    }\n    \n    // Build extraction summary\n    let extractionSummary = '';\n    if (summaries.length > 0) {\n      extractionSummary = '<ul>' + summaries.map(s => `<li>${escapeHtml(s)}</li>`).join('') + '</ul>';\n    } else {\n      extractionSummary = `<ul><li>Successfully extracted ${totalProducts} product(s) from ${validPdfs.length} file(s)</li></ul>`;\n    }\n    extractionSummary += modelInfo ? `<div class=\"model-info\">${modelInfo}</div>` : '';\n    \n    // Build exceptions section\n    let exceptionsSection = '';\n    if (exceptions.length > 0) {\n      exceptionsSection = `\n      <div class=\"exceptions\">\n        <h3>Processing Exceptions</h3>\n        <ul>`;\n      exceptions.forEach(exception => {\n        exceptionsSection += `<li>${escapeHtml(exception)}</li>`;\n      });\n      exceptionsSection += `\n        </ul>\n      </div>`;\n    }\n    \n    // Build failed files section\n    let failedFilesSection = '';\n    if (errors.length > 0) {\n      failedFilesSection = '<div class=\"failed-files\"><h3>Failed Extractions</h3><ul>';\n      for (const error of errors) {\n        failedFilesSection += `<li><strong>${escapeHtml(error.fileName)}:</strong> ${escapeHtml(error.error)}</li>`;\n      }\n      failedFilesSection += '</ul></div>';\n    }\n    \n    // Replace placeholders\n    html = html.replace('{{productTables}}', productTables);\n    html = html.replace('{{extractionSummary}}', extractionSummary);\n    html = html.replace('{{exceptionsSection}}', exceptionsSection);\n    html = html.replace('{{failedFilesSection}}', failedFilesSection);\n    html = html.replace('{{totalProducts}}', totalProducts);\n    html = html.replace('{{totalAttachments}}', validPdfs.length);\n    \n  } else {\n    // Failure template\n    let errorDetails = errors.map(e => `<strong>${escapeHtml(e.fileName)}:</strong> ${escapeHtml(e.error)}`).join('<br>');\n    html = html.replace('{{errorDetails}}', errorDetails);\n    html = html.replace('{{totalAttachments}}', validPdfs.length);\n  }\n  \n  // Request details (common to both templates)\n  const requestDetails = `\n    <table>\n      <tr><th>From</th><td>${escapeHtml(emailContext.from)}</td></tr>\n      <tr><th>Subject</th><td>${escapeHtml(emailContext.subject)}</td></tr>\n      <tr><th>Date</th><td>${new Date(emailContext.date).toUTCString()}</td></tr>\n      <tr><th>Message ID</th><td>${escapeHtml(emailContext.messageId)}</td></tr>\n    </table>`;\n  \n  html = html.replace('{{requestDetails}}', requestDetails);\n  \n  const result = {\n    to: emailContext.from,\n    subject: `Re: ${emailContext.subject} - Materials Extraction ${hasProducts ? 'Complete' : 'Failed'}`,\n    html: html\n  };\n  \n  // Debug logging - output\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Result Processor',\n    phase: 'output',\n    data: result\n  }) + '\\n');\n  \n  return result;\n};"
        }
      }
    },
    {
      "name": "send_email",
      "type": "SMTP",
      "settings": {
        "host": "{{SMTP_HOST}}",
        "port": "{{SMTP_PORT}}",
        "username": "{{EMAIL_USER}}",
        "password": "{{EMAIL_PASS}}",
        "from": "{{EMAIL_USER}}",
        "to": "{{format_results.to}}",
        "subject": "{{format_results.subject}}",
        "body": "{{format_results.html}}",
        "contentType": "html"
      }
    }
  ]
}