{
  "name": "Material Extraction from Email",
  "trigger": {
    "name": "imap",
    "type": "IMAP",
    "settings": {
      "connection": "@imap_connection",
      "mailbox": "INBOX",
      "criteria": ["UNSEEN"]
    },
    "nextAction": {
      "name": "read_config",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs').promises;\n\nmodule.exports = async (data) => {\n  try {\n    const prompt = await fs.readFile('/data/prompts/llm_extraction.txt', 'utf8');\n    const schema = JSON.parse(await fs.readFile('/data/schema/materials_schema.json', 'utf8'));\n    const successTemplate = await fs.readFile('/data/email_templates/success.html', 'utf8');\n    const failureTemplate = await fs.readFile('/data/email_templates/failure.html', 'utf8');\n\n    return {\n      prompt,\n      schema,\n      successTemplate,\n      failureTemplate\n    };\n  } catch (error) {\n    console.error('Config read error:', error.message);\n    // Continue with defaults if config files are missing\n    return {\n      prompt: 'Extract product metadata from this PDF',\n      schema: { products: [] },\n      successTemplate: '<html><body>{{productTables}}</body></html>',\n      failureTemplate: '<html><body>{{errorDetails}}</body></html>'\n    };\n  }\n};"
      }
    }
  },
  "actions": [
    {
      "name": "document_validator",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs');\n\nmodule.exports = (data) => {\n  const items = [];\n  const email = data.imap;\n  \n  // Debug logging - input\n  const inputData = { email };\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Document Validator',\n    phase: 'input',\n    data: inputData\n  }) + '\\n');\n  \n  // First item: Email context (MUST be first for result processor)\n  items.push({\n    email: {\n      subject: email.subject || 'No Subject',\n      from: email.from || 'Unknown Sender',\n      messageId: email.messageId || (email.metadata && email.metadata['message-id']) || 'no-message-id',\n      date: email.date || new Date().toISOString()\n    }\n  });\n  \n  // Process attachments - only PDFs\n  let pdfCount = 0;\n  \n  if (email.attachments && email.attachments.length > 0) {\n    for (let i = 0; i < email.attachments.length; i++) {\n      const attachment = email.attachments[i];\n      if (attachment.mimeType === 'application/pdf') {\n        // Continue processing even if fields are missing\n        const fileName = attachment.fileName || `unnamed-pdf-${pdfCount + 1}.pdf`;\n        const fileSize = attachment.size || 0;\n        \n        items.push({\n          fileName: fileName,\n          fileSize: fileSize,\n          valid: true,\n          attachmentRef: attachment  // ActivePieces file reference\n        });\n        pdfCount++;\n      }\n    }\n  }\n  \n  // Add error item if no PDFs found\n  if (pdfCount === 0) {\n    items.push({\n      fileName: 'no-pdfs-found',\n      valid: false,\n      error: 'No PDF attachments found in email',\n      errorType: 'validation'\n    });\n  }\n  \n  // Debug logging - output\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Document Validator',\n    phase: 'output',\n    data: { items }\n  }) + '\\n');\n  \n  return { items };\n};"
      },
      "nextAction": {
        "name": "loop",
        "type": "LOOP_ON_ITEMS",
        "settings": {
          "items": "{{document_validator.items}}"
        }
      }
    },
    {
      "name": "extract_metadata",
      "type": "CODE",
      "settings": {
        "code": "const fs = require('fs');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\n\nmodule.exports = async (data) => {\n  const item = data.loop.item;\n  \n  // Debug logging - input\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'LLM Extraction',\n    phase: 'input',\n    data: { item }\n  }) + '\\n');\n  \n  // Skip email context item\n  if (item.email) {\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item }\n    }) + '\\n');\n    return item;\n  }\n  \n  // Pass through invalid items\n  if (!item.valid) {\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item }\n    }) + '\\n');\n    return item;\n  }\n  \n  try {\n    // Get model name - use fallback if not set\n    const modelName = process.env.LLM_MODEL || 'gemini-2.0-flash';\n    \n    console.log('Processing file:', item.fileName);\n    console.log('Using model:', modelName);\n    \n    // Initialize Gemini\n    const apiKey = process.env.LLM_API_KEY;\n    if (!apiKey) {\n      throw new Error('LLM_API_KEY is not defined in environment variables');\n    }\n    \n    const genAI = new GoogleGenerativeAI(apiKey);\n    const model = genAI.getGenerativeModel({ \n      model: modelName,\n      generationConfig: {\n        temperature: 0.1,\n        topK: 32,\n        topP: 0.95,\n        maxOutputTokens: 8192,\n        responseMimeType: \"application/json\",\n        responseSchema: data.read_config.schema\n      }\n    });\n    \n    // Debug log attachment structure\n    const attachmentRef = item.attachmentRef;\n    if (!attachmentRef) {\n      throw new Error('No attachment reference found');\n    }\n    \n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'attachment-debug',\n      data: {\n        fileName: item.fileName,\n        attachmentRefKeys: Object.keys(attachmentRef),\n        attachmentRef: attachmentRef\n      }\n    }) + '\\n');\n    \n    // Get attachment data from ActivePieces\n    // ActivePieces provides attachments with data property\n    let pdfBase64;\n    \n    if (attachmentRef.data) {\n      // Direct data access (most common)\n      pdfBase64 = attachmentRef.data;\n    } else if (attachmentRef.content) {\n      // Alternative property name\n      pdfBase64 = attachmentRef.content;\n    } else if (attachmentRef.base64) {\n      // Already base64 encoded\n      pdfBase64 = attachmentRef.base64;\n    } else {\n      throw new Error(`Attachment data not found. Available properties: ${Object.keys(attachmentRef).join(', ')}`);\n    }\n    \n    if (!pdfBase64) {\n      throw new Error('PDF data is empty');\n    }\n    \n    console.log('PDF base64 data length:', pdfBase64.length);\n    \n    // Make API call\n    const result = await model.generateContent([\n      data.read_config.prompt + \"\\n\\nAnalyze this PDF and extract all product metadata with confidence scores. Return the result as valid JSON matching the required schema.\",\n      {\n        inlineData: {\n          mimeType: \"application/pdf\",\n          data: pdfBase64\n        }\n      }\n    ]);\n    \n    const response = await result.response;\n    const extractedContent = response.text();\n    \n    if (!extractedContent) {\n      throw new Error('No content in API response');\n    }\n    \n    const extractedData = JSON.parse(extractedContent);\n    \n    // Add source_file_name to each product\n    if (extractedData.products && Array.isArray(extractedData.products)) {\n      extractedData.products.forEach(product => {\n        if (!product.source_file_name) {\n          product.source_file_name = {\n            value: item.fileName,\n            confidence: 1.0\n          };\n        }\n      });\n    }\n    \n    const resultItem = {\n      ...item,\n      valid: true,\n      extractedData: extractedData,\n      productCount: extractedData.products ? extractedData.products.length : 0,\n      usedModel: modelName\n    };\n    \n    // Debug logging - output\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output',\n      data: { item: resultItem }\n    }) + '\\n');\n    \n    return resultItem;\n    \n  } catch (error) {\n    console.error('Extraction failed for:', item.fileName, error.message);\n    \n    // Log more detailed error information\n    if (error.response) {\n      console.error('API Error Response:', error.response);\n    }\n    \n    // Return item with error - continue processing\n    const errorItem = {\n      ...item,\n      valid: false,\n      error: error.message,\n      errorType: 'extraction'\n    };\n    \n    // Debug logging - error output\n    fs.appendFileSync('/data/debug.log', JSON.stringify({\n      timestamp: new Date().toISOString(),\n      executionId: data.executionId || 'unknown',\n      node: 'LLM Extraction',\n      phase: 'output-error',\n      data: { item: errorItem, error: error.message }\n    }) + '\\n');\n    \n    return errorItem;\n  }\n};"
      },
      "nextAction": {
        "name": "format_results",
        "type": "CODE",
        "settings": {
          "code": "const fs = require('fs');\n\nmodule.exports = (data) => {\n  // Debug logging - input\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Result Processor',\n    phase: 'input',\n    data: { itemCount: data.loop.length }\n  }) + '\\n');\n  \n  // HTML escape function for security\n  function escapeHtml(text) {\n    if (!text) return '';\n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n  \n  // Format value helper\n  function formatValue(field) {\n    if (!field) return '';\n    if (Array.isArray(field.value)) {\n      return field.value.join(', ');\n    }\n    return String(field.value || '');\n  }\n  \n  // Get all processed items\n  const allItems = data.loop || [];\n  \n  // Find email context (first item)\n  const emailContextItem = allItems.find(item => item.email && !item.fileName);\n  const emailContext = emailContextItem ? emailContextItem.email : {\n    from: 'unknown@example.com',\n    subject: 'Unknown Subject',\n    date: new Date().toISOString(),\n    messageId: 'no-message-id'\n  };\n  \n  // Separate PDF items\n  const pdfItems = allItems.filter(item => item.fileName);\n  const validPdfs = pdfItems.filter(item => item.fileName !== 'no-pdfs-found');\n  \n  // Process results\n  const errors = [];\n  const allProducts = [];\n  const summaries = [];\n  const exceptions = [];\n  \n  for (const item of pdfItems) {\n    if (!item.valid || !item.extractedData) {\n      errors.push({\n        fileName: item.fileName || 'unknown-file',\n        error: item.error || 'Unknown error',\n        errorType: item.errorType || 'unknown'\n      });\n    } else {\n      // Collect products\n      if (item.extractedData.products) {\n        for (const product of item.extractedData.products) {\n          allProducts.push({\n            product: product,\n            fileName: item.fileName\n          });\n        }\n      }\n      \n      // Collect processing summary\n      if (item.extractedData.processing_summary) {\n        summaries.push(`${item.fileName}: ${item.extractedData.processing_summary}`);\n      }\n      \n      // Collect processing exceptions\n      if (item.extractedData.processing_exceptions) {\n        if (Array.isArray(item.extractedData.processing_exceptions)) {\n          exceptions.push(...item.extractedData.processing_exceptions.map(\n            ex => `${item.fileName}: ${ex}`\n          ));\n        } else {\n          exceptions.push(`${item.fileName}: ${item.extractedData.processing_exceptions}`);\n        }\n      }\n    }\n  }\n  \n  // Get model info\n  const firstSuccess = pdfItems.find(item => item.usedModel);\n  const modelInfo = firstSuccess ? ` using model <strong>${escapeHtml(firstSuccess.usedModel)}</strong>` : '';\n  \n  // Determine which template to use\n  const hasProducts = allProducts.length > 0;\n  let html = hasProducts ? data.read_config.successTemplate : data.read_config.failureTemplate;\n  \n  // Prepare data for templates\n  // For success template\n  if (hasProducts) {\n    // Build product tables\n    let productTables = '';\n    for (const {product, fileName} of allProducts) {\n      // Header table\n      productTables += `\\n      <table class=\"header-table\">\\n        <tr>\\n          <th>Supplier</th>\\n          <th>Product Name</th>\\n          <th>SKU</th>\\n          <th>Source File</th>\\n        </tr>\\n        <tr>\\n          <td>${escapeHtml(formatValue(product.supplier))}</td>\\n          <td>${escapeHtml(formatValue(product.product_name))}</td>\\n          <td>${escapeHtml(formatValue(product.sku_number))}</td>\\n          <td>${escapeHtml(fileName)}</td>\\n        </tr>\\n      </table>`;\n      \n      // Data table\n      productTables += `\\n      <table class=\"data-table\">\\n        <tr>\\n          <th>Field</th>\\n          <th>Value</th>\\n        </tr>`;\n      \n      for (const [key, field] of Object.entries(product)) {\n        if (!['supplier', 'product_name', 'sku_number', 'source_file_name'].includes(key)) {\n          if (field && field.value !== null && field.value !== undefined && field.value !== '') {\n            const value = formatValue(field);\n            if (value && value.trim() !== '') {\n              const fieldLabel = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n              productTables += `\\n        <tr>\\n          <td>${escapeHtml(fieldLabel)}</td>\\n          <td>${escapeHtml(value)}</td>\\n        </tr>`;\n            }\n          }\n        }\n      }\n      productTables += '\\n      </table><br>';\n    }\n    \n    // Build extraction summary\n    let extractionSummary = '';\n    if (summaries.length > 0) {\n      extractionSummary = '<ul>' + summaries.map(s => `<li>${escapeHtml(s)}</li>`).join('') + '</ul>';\n    } else {\n      extractionSummary = `<ul><li>Successfully extracted ${allProducts.length} product(s) from ${validPdfs.length} file(s)</li></ul>`;\n    }\n    extractionSummary += modelInfo ? `<div class=\"model-info\">${modelInfo}</div>` : '';\n    \n    // Build exceptions section\n    let exceptionsSection = '';\n    if (exceptions.length > 0) {\n      exceptionsSection = `\\n      <div class=\"exceptions\">\\n        <h3>Processing Exceptions</h3>\\n        <ul>`;\n      exceptions.forEach(exception => {\n        exceptionsSection += `<li>${escapeHtml(exception)}</li>`;\n      });\n      exceptionsSection += `\\n        </ul>\\n      </div>`;\n    }\n    \n    // Build failed files section\n    let failedFilesSection = '';\n    if (errors.length > 0) {\n      failedFilesSection = '<div class=\"failed-files\"><h3>Failed Extractions</h3><ul>';\n      for (const error of errors) {\n        failedFilesSection += `<li><strong>${escapeHtml(error.fileName)}:</strong> ${escapeHtml(error.error)}</li>`;\n      }\n      failedFilesSection += '</ul></div>';\n    }\n    \n    // Replace placeholders\n    html = html.replace('{{productTables}}', productTables);\n    html = html.replace('{{extractionSummary}}', extractionSummary);\n    html = html.replace('{{exceptionsSection}}', exceptionsSection);\n    html = html.replace('{{failedFilesSection}}', failedFilesSection);\n    html = html.replace('{{totalProducts}}', allProducts.length);\n    html = html.replace('{{totalAttachments}}', validPdfs.length);\n    \n  } else {\n    // Failure template\n    let errorDetails = '';\n    if (errors.length > 0) {\n      errorDetails = errors.map(e => `<strong>${escapeHtml(e.fileName)}:</strong> ${escapeHtml(e.error)}`).join('<br>');\n    } else {\n      errorDetails = 'No specific error details available.';\n    }\n    \n    html = html.replace('{{errorDetails}}', errorDetails);\n    html = html.replace('{{totalAttachments}}', validPdfs.length);\n  }\n  \n  // Request details (common to both templates)\n  const requestDetails = `\\n    <table>\\n      <tr><th>From</th><td>${escapeHtml(emailContext.from)}</td></tr>\\n      <tr><th>Subject</th><td>${escapeHtml(emailContext.subject)}</td></tr>\\n      <tr><th>Date</th><td>${escapeHtml(emailContext.date)}</td></tr>\\n      <tr><th>Message ID</th><td>${escapeHtml(emailContext.messageId)}</td></tr>\\n    </table>`;\n  \n  html = html.replace('{{requestDetails}}', requestDetails);\n  \n  const result = {\n    to: emailContext.from,\n    subject: `Re: ${emailContext.subject} - Materials Extraction ${hasProducts ? 'Complete' : 'Failed'}`,\n    html: html\n  };\n  \n  // Debug logging - output\n  fs.appendFileSync('/data/debug.log', JSON.stringify({\n    timestamp: new Date().toISOString(),\n    executionId: data.executionId || 'unknown',\n    node: 'Result Processor',\n    phase: 'output',\n    data: result\n  }) + '\\n');\n  \n  return result;\n};"
        }
      }
    },
    {
      "name": "send_email",
      "type": "SMTP",
      "settings": {
        "connection": "@smtp_connection",
        "from": "@email_from",
        "to": "{{format_results.to}}",
        "subject": "{{format_results.subject}}",
        "body": "{{format_results.html}}",
        "contentType": "html"
      }
    }
  ]
}