{
  "name": "Materials Intake Pipeline V1 Multimodal",
  "nodes": [
    {
      "parameters": {
        "protocol": "IMAP",
        "host": "={{ $env.IMAP_HOST }}",
        "port": "={{ $env.IMAP_PORT }}",
        "secure": true,
        "mailbox": "INBOX",
        "downloadAttachments": true,
        "attachmentPrefix": "attachment_",
        "options": {
          "allowUnauthorizedCerts": false,
          "ignoreTextEncoding": false
        }
      },
      "id": "1",
      "name": "Email Trigger",
      "type": "n8n-nodes-base.emailReadImap",
      "typeVersion": 1,
      "position": [
        100,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Get code from functions_multimodal.js\nconst functions = require('./functions_multimodal.js');\nreturn functions.documentValidator(items, runIndex);"
      },
      "id": "3",
      "name": "Document Validator",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        300,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "httpMethod": "POST",
        "url": "={{ $env.LLM_VISION_API_ENDPOINT }}",
        "jsonParameters": true,
        "options": {
          "allowUnauthorizedCerts": false,
          "response": {
            "response": {
              "maxResponseSize": 10485760,
              "responseFormat": "json",
              "responseType": "json"
            }
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.LLM_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "prompt",
              "value": "=The contents of file {{ $node[\"Document Validator\"].json[\"file_path\"] }} - Extract all available metadata according to the metadata_extraction.txt prompt."
            },
            {
              "name": "model",
              "value": "={{ $env.LLM_VISION_MODEL }}"
            },
            {
              "name": "temperature",
              "value": 0.2
            },
            {
              "name": "max_tokens",
              "value": 8000
            },
            {
              "name": "include_pdf",
              "value": true
            }
          ]
        },
        "postReceive": {
          "enabled": true,
          "type": "jsonTranform",
          "jsonTranform": {
            "transformationInstructions": "// Transform extraction response to needed format\nconst filePath = $node[\"Document Validator\"].json.file_path || \"\";\nconst isRetry = $node[\"Document Validator\"].json.task === \"retry_extraction\";\nconst retryCount = $node[\"Document Validator\"].json.retry_count || 0;\nconst documentId = $node[\"Document Validator\"].json.document_id;\n\n// Parse the LLM extraction result\ntry {\n  const extractedData = $input.all();\n  \n  // Get just the extraction data, not the wrapper\n  const extractedMetadata = extractedData.body;\n  \n  // Convert to standard metadata_json format\n  const standardMetadata = {};\n  for (const [key, data] of Object.entries(extractedMetadata)) {\n    standardMetadata[key] = data.value;\n  }\n  \n  // Create field confidence mapping\n  const fieldConfidences = {};\n  for (const [key, data] of Object.entries(extractedMetadata)) {\n    fieldConfidences[key] = data.confidence;\n  }\n  \n  // Prepare response with the same format that Metadata Parser produced\n  const result = {\n    metadata_json: standardMetadata,\n    field_extractions: extractedMetadata,\n    _metadata: {\n      prompt_id: isRetry ? \"multimodal-v1.0-retry\" : \"multimodal-v1.0\",\n      model_version: \"gemini-pro-vision\",\n      generated_ts: new Date().toISOString(),\n      is_retry: isRetry,\n      retry_count: retryCount,\n      multimodal_extraction: true,\n      source_file_name: filePath.split('/').pop() || \"unknown\"\n    },\n    // field_locations removed (duplication of field_extractions)\n    field_confidences: fieldConfidences,\n    _lifecycle_log: $node[\"Document Validator\"].json._lifecycle_log || [],\n    document_id: documentId,\n    retry_count: retryCount,\n    original_request: isRetry ? $node[\"Document Validator\"].json.original_request : $node[\"Document Validator\"].json\n  };\n  \n  // Add lifecycle log entry\n  result._lifecycle_log.push({\n    document_id: documentId,\n    from_state: isRetry ? \"RETRY_EXTRACTION\" : \"INTERPRETED\",\n    to_state: \"EXTRACTED\",\n    timestamp: new Date().toISOString(),\n    agent: \"multimodal_metadata_extractor_v1\",\n    notes: isRetry ? \n      `Retry extraction attempt ${retryCount} completed` : \n      \"Multimodal extraction with visual coordinates completed\"\n  });\n  \n  return { json: result };\n} catch (error) {\n  // Error handling similar to the one in multimodalMetadataExtractor\n  const errorEntry = {\n    document_id: documentId,\n    from_state: isRetry ? \"RETRY_EXTRACTION\" : \"INTERPRETED\",\n    to_state: \"FAILED\",\n    timestamp: new Date().toISOString(),\n    agent: \"multimodal_metadata_extractor_v1\",\n    notes: `Multimodal extraction failed: ${error.message}`\n  };\n  \n  return {\n    json: {\n      task_status: \"failed\",\n      error_summary: `Multimodal metadata extraction failed: ${error.message}`,\n      document_id: documentId,\n      retry_count: retryCount,\n      _lifecycle_log: [...($node[\"Document Validator\"].json._lifecycle_log || []), errorEntry]\n    }\n  };\n}"
          }
        }
      },
      "id": "4",
      "name": "LLM Extraction",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        500,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "httpMethod": "POST",
        "url": "={{ $env.LLM_TEXT_API_ENDPOINT }}",
        "jsonParameters": true,
        "options": {
          "allowUnauthorizedCerts": false,
          "response": {
            "response": {
              "maxResponseSize": 10485760,
              "responseFormat": "json",
              "responseType": "json"
            }
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.LLM_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "prompt",
              "value": "=The content of the data_processor.txt prompt. You'll be analyzing the following extracted metadata: {{ $json.metadata_json }} with field confidences: {{ $json.field_confidences }}. Make a decision about how to proceed."
            },
            {
              "name": "model",
              "value": "={{ $env.LLM_TEXT_MODEL }}"
            },
            {
              "name": "temperature",
              "value": 0.1
            },
            {
              "name": "max_tokens",
              "value": 4000
            }
          ]
        }
      },
      "id": "6",
      "name": "LLM Data Processor",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        900,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "httpMethod": "POST",
        "url": "={{ $env.LLM_VISION_API_ENDPOINT }}",
        "jsonParameters": true,
        "options": {
          "allowUnauthorizedCerts": false,
          "response": {
            "response": {
              "maxResponseSize": 10485760,
              "responseFormat": "json",
              "responseType": "json"
            }
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.LLM_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "prompt",
              "value": "=The contents of the metadata_verification.txt prompt. You'll be verifying the following metadata: {{ $json.metadata_json }} against the document at {{ $node[\"Document Validator\"].json[\"file_path\"] }}. Use the field coordinates provided in {{ $json.field_extractions }} to guide your verification."
            },
            {
              "name": "model",
              "value": "={{ $env.LLM_VISION_MODEL }}"
            },
            {
              "name": "temperature",
              "value": 0.1
            },
            {
              "name": "max_tokens",
              "value": 6000
            },
            {
              "name": "include_pdf",
              "value": true
            }
          ]
        }
      },
      "id": "7",
      "name": "LLM Verifier",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1100,
        100
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.verification_passed }}",
              "operation": "equals",
              "value2": "true"
            }
          ]
        }
      },
      "id": "8",
      "name": "Validation Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1300,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Get code from functions_multimodal.js\nconst functions = require('./functions_multimodal.js');\nreturn functions.formatSuccessEmail(items, runIndex);"
      },
      "id": "9",
      "name": "Success Notifier",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1500,
        50
      ]
    },
    {
      "parameters": {
        "functionCode": "// Get code from functions_multimodal.js\nconst functions = require('./functions_multimodal.js');\nreturn functions.formatErrorEmail(items, runIndex);"
      },
      "id": "10",
      "name": "Error Notifier",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1500,
        150
      ]
    },
    {
      "parameters": {
        "fromEmail": "={{ $env.SMTP_USER }}",
        "toEmail": "={{ $json[\"to\"] }}",
        "subject": "={{ $json[\"subject\"] }}",
        "text": "={{ $json[\"body\"] }}",
        "options": {
          "attachments": "={{ $json[\"attachments\"] }}"
        }
      },
      "id": "11",
      "name": "Send Notification",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 1,
      "position": [
        1700,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log all document lifecycle stages to a file\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst logPath = process.env.LOG_PATH || './logs';\nconst logFile = path.join(logPath, 'document_lifecycle.json');\n\n// Ensure log directory exists\nif (!fs.existsSync(logPath)) {\n  fs.mkdirSync(logPath, { recursive: true });\n}\n\n// Get existing logs or create new array\nlet logs = [];\nif (fs.existsSync(logFile)) {\n  try {\n    const data = fs.readFileSync(logFile, 'utf8');\n    logs = JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading logs file:', err);\n  }\n}\n\n// Add new log entries\nif (items[0].json._lifecycle_log && Array.isArray(items[0].json._lifecycle_log)) {\n  logs = logs.concat(items[0].json._lifecycle_log);\n  \n  // Write updated logs\n  try {\n    fs.writeFileSync(logFile, JSON.stringify(logs, null, 2));\n  } catch (err) {\n    console.error('Error writing logs file:', err);\n  }\n}\n\n// Pass through the original items\nreturn items;"
      },
      "id": "12",
      "name": "Activity Logger",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1900,
        100
      ]
    },
    {
      "parameters": {
        "dataPropertyName": "error",
        "errorMessage": "=Document Processor Error: {{ $json.error_message || 'Unknown error' }}"
      },
      "id": "14",
      "name": "Global Error Handler",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [
        100,
        250
      ]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "error_message",
              "value": "={{ $json.error }}"
            },
            {
              "name": "document_id",
              "value": "={{ $json.document_id || 'unknown-doc' }}"
            },
            {
              "name": "timestamp",
              "value": "={{ $now.toISOString() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "15",
      "name": "Error Formatter",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        300,
        250
      ]
    }
  ],
  "connections": {
    "Email Trigger": {
      "main": [
        [
          {
            "node": "Document Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Validator": {
      "main": [
        [
          {
            "node": "LLM Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extraction": {
      "main": [
        [
          {
            "node": "LLM Data Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Data Processor": {
      "main": [
        [
          {
            "node": "LLM Verifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Verifier": {
      "main": [
        [
          {
            "node": "Validation Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Router": {
      "main": [
        [
          {
            "node": "Success Notifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Notifier": {
      "main": [
        [
          {
            "node": "Send Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Notifier": {
      "main": [
        [
          {
            "node": "Send Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Notification": {
      "main": [
        [
          {
            "node": "Activity Logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Global Error Handler": {
      "main": [
        [
          {
            "node": "Error Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Formatter": {
      "main": [
        [
          {
            "node": "Error Notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}